
# 基本データ型

- Golang には４種類の型がある：基本型、合成型、参照型、インタフェース型
  - 配列, 構造体は合成型
  - pointer, slice, map, channel は参照型

## 3.1 整数
Golang の数値型 : 整数、浮動小数点数、複素数

- size : 8 ..64 bit
- 符号ありなし : int, uint で区別
  - size を指定しない型はプラットフォーム依存で size が変わる, int, uint, uintptr
- rune は int32 の synonym で unicode codepoint を値とする（charっぽい）
- byte は uint8 の synonym, 生データを扱うのに利用することが多い
- uintptr はポインタを扱うのに使う
- 他の言語とほぼ共通
  - 符号付きは２の補数で表現
  - 二項演算子の優先順位
- 剰余の符号は被除数のものになる
- overflow したら上位ビットは切り捨てとなる
  - 場合によっては符号が逆になったりする : p.59
- 基本型間は二項比較演算子が適用可能であり順序付けもなされる
- +x は 0+x, -x は 0-x と同意
- `^` は二項演算ならXOR(排他和)だが単一なら補数
- `^&` は ANDNOT(ビットクリア) : p.60
- ビットシフトを符号付き演算でやると空いたビットを符号値で埋めてしまう
- 符号なし数値を使うことは少ない
  - 組み込みの len 関数は符号付き数値を返すので, ループインデックスの初期値として len の結果を与えても不具合を起こさないようになっている : p.61
- オペランドの型を揃えなければ算術不可能
  - 型を変更する場合は変換演算を用いる
  - int32(), float64(), rune(), ..
- fmt の verb に `#` をつけると接頭辞をつけることができる
  - `%#x` なら 0xff などとなる : p.62

## 3.2 浮動小数点数

- float32, float64 は IEEE 754 標準ですべての CPU で扱える
- float32 は 3.4e38, float64 は 1.8e308 まで扱える
  - float32 は１０進で６桁程度まで、float64 は１５桁程度までの精度で扱える
- verb は %g, %e, %f がある
- NaN との比較は常に false となるので直接番兵としては使えない
  - IsNaN 関数により NaN かどうか検査可能

## 3.3 複素数

- 実部と虚部を float32, float64 でそれぞれ実装した complex64, complex128 がある
  - real と imag 関数により実部と虚部を取り出せる
  - suffix に `i` をつけると虚部リテラルとなる : p68
- math/cmplx に sqrt など所々の操作関数が定義されている

## 3.4 ブーリアン

- `&&` は short-circuit 評価
  - 左項から順に評価し false となったらそこで評価を打ち切る
  - `||` は左項が true となったら評価を打ち切る
- bool から他型へは直接変換できない


